package main

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/coder/guts"
	"github.com/coder/guts/config"
)

func main() {
	golang, err := guts.NewGolangParser()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create parser: %v\n", err)
		os.Exit(1)
	}

	// Generate TypeScript types for all relevant internal packages
	// Only include packages with types that the frontend needs
	packages := []string{
		"github.com/maksimkurb/keen-pbr/src/internal/api",
		"github.com/maksimkurb/keen-pbr/src/internal/config",
		"github.com/maksimkurb/keen-pbr/src/internal/service",
		// Note: keenetic package is excluded - it's internal implementation only
	}

	for _, pkg := range packages {
		if err := golang.IncludeGenerate(pkg); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to include package %s: %v\n", pkg, err)
			os.Exit(1)
		}
	}

	// Map Go types to TypeScript types
	if err := golang.IncludeCustom(map[string]string{
		"time.Time": "string",
	}); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to add custom mappings: %v\n", err)
		os.Exit(1)
	}

	// Use standard mappings (error, etc.)
	golang.IncludeCustomDeclaration(config.StandardMappings())

	// Exclude internal implementation types (not needed in frontend)
	excludeTypes := []string{
		// Service implementations
		"github.com/maksimkurb/keen-pbr/src/internal/service.DNSService",
		"github.com/maksimkurb/keen-pbr/src/internal/service.InterfaceService",
		// API handlers
		"github.com/maksimkurb/keen-pbr/src/internal/api.Handler",
		"github.com/maksimkurb/keen-pbr/src/internal/api.ServiceManager",
		"github.com/maksimkurb/keen-pbr/src/internal/api.DNSCheckSubscriber",
		"github.com/maksimkurb/keen-pbr/src/internal/api.DNSServersProvider",
		// Type aliases (to avoid duplicates - use the original from service package)
		"github.com/maksimkurb/keen-pbr/src/internal/api.DNSServerInfo",
		"github.com/maksimkurb/keen-pbr/src/internal/api.InterfaceInfo",
		// Config internal types
		"github.com/maksimkurb/keen-pbr/src/internal/config.ConfigHasher",
		"github.com/maksimkurb/keen-pbr/src/internal/config.DNSProvider",
		// Keenetic package (internal client types)
		"github.com/maksimkurb/keen-pbr/src/internal/keenetic",
	}

	for _, t := range excludeTypes {
		if err := golang.ExcludeCustom(t); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to exclude type %s: %v\n", t, err)
			os.Exit(1)
		}
	}

	// Preserve Go comments in TypeScript output
	golang.PreserveComments()

	// Convert Go types to TypeScript AST
	ts, err := golang.ToTypescript()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to convert to TypeScript: %v\n", err)
		os.Exit(1)
	}

	// Apply mutations to make output idiomatic
	ts.ApplyMutations(
		// Export all top-level types
		config.ExportTypes,
	)

	// Serialize TypeScript AST to string
	output, err := ts.Serialize()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to serialize TypeScript: %v\n", err)
		os.Exit(1)
	}

	// Add header comment
	header := `/* eslint-disable */
/**
 * This file was automatically generated by guts.
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * To regenerate this file, run:
 *   make generate-types
 */

`

	// Write to output file
	outputPath := filepath.Join("src", "frontend", "src", "api", "generated-types.ts")
	fullOutput := header + output

	if err := os.WriteFile(outputPath, []byte(fullOutput), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to write output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("âœ“ Generated TypeScript types to %s\n", outputPath)
}
